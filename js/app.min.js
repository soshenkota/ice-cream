(() => { "use strict"; const e = {}; function t() { if (location.hash) return location.hash.replace("#", "") } let s = !0, i = (e = 500) => { let t = document.querySelector("body"); if (s) { let i = document.querySelectorAll("[data-lp]"); setTimeout((() => { for (let e = 0; e < i.length; e++) { i[e].style.paddingRight = "0px" } t.style.paddingRight = "0px", document.documentElement.classList.remove("lock") }), e), s = !1, setTimeout((function () { s = !0 }), e) } }, a = (e = 500) => { let t = document.querySelector("body"); if (s) { let i = document.querySelectorAll("[data-lp]"); for (let e = 0; e < i.length; e++) { i[e].style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px" } t.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px", document.documentElement.classList.add("lock"), s = !1, setTimeout((function () { s = !0 }), e) } }; function r() { i(), document.documentElement.classList.remove("menu-open") } function n(e) { setTimeout((() => { window.FLS && console.log(e) }), 0) } function o(e) { return e.filter((function (e, t, s) { return s.indexOf(e) === t })) } e.popup = new class { constructor(e) { let t = { logging: !0, init: !0, attributeOpenButton: "data-popup", attributeCloseButton: "data-close", fixElementSelector: "[data-lp]", youtubeAttribute: "data-popup-youtube", youtubePlaceAttribute: "data-popup-youtube-place", setAutoplayYoutube: !0, classes: { popup: "popup", popupContent: "popup__content", popupActive: "popup_show", bodyActive: "popup-show" }, focusCatch: !0, closeEsc: !0, bodyLock: !0, hashSettings: { location: !0, goHash: !0 }, on: { beforeOpen: function () { }, afterOpen: function () { }, beforeClose: function () { }, afterClose: function () { } } }; this.youTubeCode, this.isOpen = !1, this.targetOpen = { selector: !1, element: !1 }, this.previousOpen = { selector: !1, element: !1 }, this.lastClosed = { selector: !1, element: !1 }, this._dataValue = !1, this.hash = !1, this._reopen = !1, this._selectorOpen = !1, this.lastFocusEl = !1, this._focusEl = ["a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'], this.options = { ...t, ...e, classes: { ...t.classes, ...e?.classes }, hashSettings: { ...t.hashSettings, ...e?.hashSettings }, on: { ...t.on, ...e?.on } }, this.bodyLock = !1, this.options.init && this.initPopups() } initPopups() { this.popupLogging("Прокинувся"), this.eventsPopup() } eventsPopup() { document.addEventListener("click", function (e) { const t = e.target.closest(`[${this.options.attributeOpenButton}]`); if (t) return e.preventDefault(), this._dataValue = t.getAttribute(this.options.attributeOpenButton) ? t.getAttribute(this.options.attributeOpenButton) : "error", this.youTubeCode = t.getAttribute(this.options.youtubeAttribute) ? t.getAttribute(this.options.youtubeAttribute) : null, "error" !== this._dataValue ? (this.isOpen || (this.lastFocusEl = t), this.targetOpen.selector = `${this._dataValue}`, this._selectorOpen = !0, void this.open()) : void this.popupLogging(`Йой, не заповнено атрибут у ${t.classList}`); return e.target.closest(`[${this.options.attributeCloseButton}]`) || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen ? (e.preventDefault(), void this.close()) : void 0 }.bind(this)), document.addEventListener("keydown", function (e) { if (this.options.closeEsc && 27 == e.which && "Escape" === e.code && this.isOpen) return e.preventDefault(), void this.close(); this.options.focusCatch && 9 == e.which && this.isOpen && this._focusCatch(e) }.bind(this)), this.options.hashSettings.goHash && (window.addEventListener("hashchange", function () { window.location.hash ? this._openToHash() : this.close(this.targetOpen.selector) }.bind(this)), window.addEventListener("load", function () { window.location.hash && this._openToHash() }.bind(this))) } open(e) { if (s) if (this.bodyLock = !(!document.documentElement.classList.contains("lock") || this.isOpen), e && "string" == typeof e && "" !== e.trim() && (this.targetOpen.selector = e, this._selectorOpen = !0), this.isOpen && (this._reopen = !0, this.close()), this._selectorOpen || (this.targetOpen.selector = this.lastClosed.selector), this._reopen || (this.previousActiveElement = document.activeElement), this.targetOpen.element = document.querySelector(this.targetOpen.selector), this.targetOpen.element) { if (this.youTubeCode) { const e = `https://www.youtube.com/embed/${this.youTubeCode}?rel=0&showinfo=0&autoplay=1`, t = document.createElement("iframe"); t.setAttribute("allowfullscreen", ""); const s = this.options.setAutoplayYoutube ? "autoplay;" : ""; if (t.setAttribute("allow", `${s}; encrypted-media`), t.setAttribute("src", e), !this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) { this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "") } this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(t) } this.options.hashSettings.location && (this._getHash(), this._setHash()), this.options.on.beforeOpen(this), document.dispatchEvent(new CustomEvent("beforePopupOpen", { detail: { popup: this } })), this.targetOpen.element.classList.add(this.options.classes.popupActive), document.documentElement.classList.add(this.options.classes.bodyActive), this._reopen ? this._reopen = !1 : !this.bodyLock && a(), this.targetOpen.element.setAttribute("aria-hidden", "false"), this.previousOpen.selector = this.targetOpen.selector, this.previousOpen.element = this.targetOpen.element, this._selectorOpen = !1, this.isOpen = !0, setTimeout((() => { this._focusTrap() }), 50), this.options.on.afterOpen(this), document.dispatchEvent(new CustomEvent("afterPopupOpen", { detail: { popup: this } })), this.popupLogging("Відкрив попап") } else this.popupLogging("Йой, такого попапу немає. Перевірте коректність введення. ") } close(e) { e && "string" == typeof e && "" !== e.trim() && (this.previousOpen.selector = e), this.isOpen && s && (this.options.on.beforeClose(this), document.dispatchEvent(new CustomEvent("beforePopupClose", { detail: { popup: this } })), this.youTubeCode && this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`) && (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = ""), this.previousOpen.element.classList.remove(this.options.classes.popupActive), this.previousOpen.element.setAttribute("aria-hidden", "true"), this._reopen || (document.documentElement.classList.remove(this.options.classes.bodyActive), !this.bodyLock && i(), this.isOpen = !1), this._removeHash(), this._selectorOpen && (this.lastClosed.selector = this.previousOpen.selector, this.lastClosed.element = this.previousOpen.element), this.options.on.afterClose(this), document.dispatchEvent(new CustomEvent("afterPopupClose", { detail: { popup: this } })), setTimeout((() => { this._focusTrap() }), 50), this.popupLogging("Закрив попап")) } _getHash() { this.options.hashSettings.location && (this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#")) } _openToHash() { let e = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null; const t = document.querySelector(`[${this.options.attributeOpenButton} = "${e}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${e}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${e.replace(".", "#")}"]`); this.youTubeCode = t.getAttribute(this.options.youtubeAttribute) ? t.getAttribute(this.options.youtubeAttribute) : null, t && e && this.open(e) } _setHash() { history.pushState("", "", this.hash) } _removeHash() { history.pushState("", "", window.location.href.split("#")[0]) } _focusCatch(e) { const t = this.targetOpen.element.querySelectorAll(this._focusEl), s = Array.prototype.slice.call(t), i = s.indexOf(document.activeElement); e.shiftKey && 0 === i && (s[s.length - 1].focus(), e.preventDefault()), e.shiftKey || i !== s.length - 1 || (s[0].focus(), e.preventDefault()) } _focusTrap() { const e = this.previousOpen.element.querySelectorAll(this._focusEl); !this.isOpen && this.lastFocusEl ? this.lastFocusEl.focus() : e[0].focus() } popupLogging(e) { this.options.logging && n(`[Попапос]: ${e}`) } }({}); let l = (e, t = !1, s = 500, i = 0) => { const a = document.querySelector(e); if (a) { let o = "", l = 0; if (t) { o = "header.header"; const e = document.querySelector(o); e.classList.contains("_header-scroll") ? l = e.offsetHeight : (e.style.cssText = "transition-duration: 0s;", e.classList.add("_header-scroll"), l = e.offsetHeight, e.classList.remove("_header-scroll"), setTimeout((() => { e.style.cssText = "" }), 0)) } let d = { speedAsDuration: !0, speed: s, header: o, offset: i, easing: "easeOutQuad" }; if (document.documentElement.classList.contains("menu-open") && r(), "undefined" != typeof SmoothScroll) (new SmoothScroll).animateScroll(a, "", d); else { let e = a.getBoundingClientRect().top + scrollY; e = l ? e - l : e, e = i ? e - i : e, window.scrollTo({ top: e, behavior: "smooth" }) } n(`[gotoBlock]: Юхуу...їдемо до ${e}`) } else n(`[gotoBlock]: Йой... Такого блоку немає на сторінці: ${e}`) }; let d = { getErrors(e) { let t = 0, s = e.querySelectorAll("*[data-required]"); return s.length && s.forEach((e => { null === e.offsetParent && "SELECT" !== e.tagName || e.disabled || (t += this.validateInput(e)) })), t }, validateInput(e) { let t = 0; return "email" === e.dataset.required ? (e.value = e.value.replace(" ", ""), this.emailTest(e) ? (this.addError(e), t++) : this.removeError(e)) : ("checkbox" !== e.type || e.checked) && e.value.trim() ? this.removeError(e) : (this.addError(e), t++), t }, addError(e) { e.classList.add("_form-error"), e.parentElement.classList.add("_form-error"); let t = e.parentElement.querySelector(".form__error"); t && e.parentElement.removeChild(t), e.dataset.error && e.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${e.dataset.error}</div>`) }, removeError(e) { e.classList.remove("_form-error"), e.parentElement.classList.remove("_form-error"), e.parentElement.querySelector(".form__error") && e.parentElement.removeChild(e.parentElement.querySelector(".form__error")) }, formClean(t) { t.reset(), setTimeout((() => { let s = t.querySelectorAll("input,textarea"); for (let e = 0; e < s.length; e++) { const t = s[e]; t.parentElement.classList.remove("_form-focus"), t.classList.remove("_form-focus"), d.removeError(t) } let i = t.querySelectorAll(".checkbox__input"); if (i.length > 0) for (let e = 0; e < i.length; e++) { i[e].checked = !1 } if (e.select) { let s = t.querySelectorAll(".select"); if (s.length) for (let t = 0; t < s.length; t++) { const i = s[t].querySelector("select"); e.select.selectBuild(i) } } }), 0) }, emailTest: e => !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(e.value) }; function c(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function p(e, t) { void 0 === e && (e = {}), void 0 === t && (t = {}), Object.keys(t).forEach((s => { void 0 === e[s] ? e[s] = t[s] : c(t[s]) && c(e[s]) && Object.keys(t[s]).length > 0 && p(e[s], t[s]) })) } const u = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function h() { const e = "undefined" != typeof document ? document : {}; return p(e, u), e } const m = { document: u, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function f() { const e = "undefined" != typeof window ? window : {}; return p(e, m), e } function g(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function v() { return Date.now() } function w(e, t) { void 0 === t && (t = "x"); const s = f(); let i, a, r; const n = function (e) { const t = f(); let s; return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s }(e); return s.WebKitCSSMatrix ? (a = n.transform || n.webkitTransform, a.split(",").length > 6 && (a = a.split(", ").map((e => e.replace(",", "."))).join(", ")), r = new s.WebKitCSSMatrix("none" === a ? "" : a)) : (r = n.MozTransform || n.OTransform || n.MsTransform || n.msTransform || n.transform || n.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = r.toString().split(",")), "x" === t && (a = s.WebKitCSSMatrix ? r.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (a = s.WebKitCSSMatrix ? r.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), a || 0 } function b(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function S() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < arguments.length; i += 1) { const a = i < 0 || arguments.length <= i ? void 0 : arguments[i]; if (null != a && (s = a, !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) { const s = Object.keys(Object(a)).filter((e => t.indexOf(e) < 0)); for (let t = 0, i = s.length; t < i; t += 1) { const i = s[t], r = Object.getOwnPropertyDescriptor(a, i); void 0 !== r && r.enumerable && (b(e[i]) && b(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : S(e[i], a[i]) : !b(e[i]) && b(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : S(e[i], a[i])) : e[i] = a[i]) } } } var s; return e } function y(e, t, s) { e.style.setProperty(t, s) } function E(e) { let { swiper: t, targetPosition: s, side: i } = e; const a = f(), r = -t.translate; let n, o = null; const l = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(t.cssModeFrameID); const d = s > r ? "next" : "prev", c = (e, t) => "next" === d && e >= t || "prev" === d && e <= t, p = () => { n = (new Date).getTime(), null === o && (o = n); const e = Math.max(Math.min((n - o) / l, 1), 0), d = .5 - Math.cos(e * Math.PI) / 2; let u = r + d * (s - r); if (c(u, s) && (u = s), t.wrapperEl.scrollTo({ [i]: u }), c(u, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [i]: u }) })), void a.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = a.requestAnimationFrame(p) }; p() } function T(e, t) { return void 0 === t && (t = ""), [...e.children].filter((e => e.matches(t))) } function x(e, t) { void 0 === t && (t = []); const s = document.createElement(e); return s.classList.add(...Array.isArray(t) ? t : [t]), s } function C(e, t) { return f().getComputedStyle(e, null).getPropertyValue(t) } function L(e) { let t, s = e; if (s) { for (t = 0; null !== (s = s.previousSibling);)1 === s.nodeType && (t += 1); return t } } function M(e, t) { const s = []; let i = e.parentElement; for (; i;)t ? i.matches(t) && s.push(i) : s.push(i), i = i.parentElement; return s } function A(e, t, s) { const i = f(); return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } let P, O, k; function _() { return P || (P = function () { const e = f(), t = h(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), P } function I(e) { return void 0 === e && (e = {}), O || (O = function (e) { let { userAgent: t } = void 0 === e ? {} : e; const s = _(), i = f(), a = i.navigator.platform, r = t || i.navigator.userAgent, n = { ios: !1, android: !1 }, o = i.screen.width, l = i.screen.height, d = r.match(/(Android);?[\s\/]+([\d.]+)?/); let c = r.match(/(iPad).*OS\s([\d_]+)/); const p = r.match(/(iPod)(.*OS\s([\d_]+))?/), u = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), h = "Win32" === a; let m = "MacIntel" === a; return !c && m && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${l}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), m = !1), d && !h && (n.os = "android", n.android = !0), (c || u || p) && (n.os = "ios", n.ios = !0), n }(e)), O } function z() { return k || (k = function () { const e = f(); let t = !1; function s() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 } if (s()) { const s = String(e.navigator.userAgent); if (s.includes("Version/")) { const [e, i] = s.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e))); t = e < 16 || 16 === e && i < 2 } } return { isSafari: t || s(), needPerspectiveFix: t, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), k } var $ = { on(e, t, s) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof t) return i; const a = s ? "unshift" : "push"; return e.split(" ").forEach((e => { i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][a](t) })), i }, once(e, t, s) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof t) return i; function a() { i.off(e, a), a.__emitterProxy && delete a.__emitterProxy; for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++)r[n] = arguments[n]; t.apply(i, r) } return a.__emitterProxy = t, i.on(e, a, s) }, onAny(e, t) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof e) return s; const i = t ? "unshift" : "push"; return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[i](e), s }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const s = t.eventsAnyListeners.indexOf(e); return s >= 0 && t.eventsAnyListeners.splice(s, 1), t }, off(e, t) { const s = this; return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((i, a) => { (i === t || i.__emitterProxy && i.__emitterProxy === t) && s.eventsListeners[e].splice(a, 1) })) })), s) : s }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, s, i; for (var a = arguments.length, r = new Array(a), n = 0; n < a; n++)r[n] = arguments[n]; "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), i = e) : (t = r[0].events, s = r[0].data, i = r[0].context || e), s.unshift(i); return (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(i, [t, ...s]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(i, s) })) })), e } }; const G = (e, t) => { if (!e || e.destroyed || !e.params) return; const s = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`); if (s) { let t = s.querySelector(`.${e.params.lazyPreloaderClass}`); !t && e.isElement && (s.shadowRoot ? t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((() => { s.shadowRoot && (t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove()) }))), t && t.remove() } }, D = (e, t) => { if (!e.slides[t]) return; const s = e.slides[t].querySelector('[loading="lazy"]'); s && s.removeAttribute("loading") }, q = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const s = e.slides.length; if (!s || !t || t < 0) return; t = Math.min(t, s); const i = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), a = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const s = a, r = [s - t]; return r.push(...Array.from({ length: t }).map(((e, t) => s + i + t))), void e.slides.forEach(((t, s) => { r.includes(t.column) && D(e, s) })) } const r = a + i - 1; if (e.params.rewind || e.params.loop) for (let i = a - t; i <= r + t; i += 1) { const t = (i % s + s) % s; (t < a || t > r) && D(e, t) } else for (let i = Math.max(a - t, 0); i <= Math.min(r + t, s - 1); i += 1)i !== a && (i > r || i < a) && D(e, i) }; var B = { updateSize: function () { const e = this; let t, s; const i = e.el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : i.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : i.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(C(i, "padding-left") || 0, 10) - parseInt(C(i, "padding-right") || 0, 10), s = s - parseInt(C(i, "padding-top") || 0, 10) - parseInt(C(i, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function s(e, s) { return parseFloat(e.getPropertyValue(t(s)) || 0) } const i = e.params, { wrapperEl: a, slidesEl: r, size: n, rtlTranslate: o, wrongRTL: l } = e, d = e.virtual && i.virtual.enabled, c = d ? e.virtual.slides.length : e.slides.length, p = T(r, `.${e.params.slideClass}, swiper-slide`), u = d ? e.virtual.slides.length : p.length; let h = []; const m = [], f = []; let g = i.slidesOffsetBefore; "function" == typeof g && (g = i.slidesOffsetBefore.call(e)); let v = i.slidesOffsetAfter; "function" == typeof v && (v = i.slidesOffsetAfter.call(e)); const w = e.snapGrid.length, b = e.slidesGrid.length; let S = i.spaceBetween, E = -g, x = 0, L = 0; if (void 0 === n) return; "string" == typeof S && S.indexOf("%") >= 0 ? S = parseFloat(S.replace("%", "")) / 100 * n : "string" == typeof S && (S = parseFloat(S)), e.virtualSize = -S, p.forEach((e => { o ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" })), i.centeredSlides && i.cssMode && (y(a, "--swiper-centered-offset-before", ""), y(a, "--swiper-centered-offset-after", "")); const M = i.grid && i.grid.rows > 1 && e.grid; let P; M && e.grid.initSlides(u); const O = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0; for (let a = 0; a < u; a += 1) { let r; if (P = 0, p[a] && (r = p[a]), M && e.grid.updateSlide(a, r, u, t), !p[a] || "none" !== C(r, "display")) { if ("auto" === i.slidesPerView) { O && (p[a].style[t("width")] = ""); const n = getComputedStyle(r), o = r.style.transform, l = r.style.webkitTransform; if (o && (r.style.transform = "none"), l && (r.style.webkitTransform = "none"), i.roundLengths) P = e.isHorizontal() ? A(r, "width", !0) : A(r, "height", !0); else { const e = s(n, "width"), t = s(n, "padding-left"), i = s(n, "padding-right"), a = s(n, "margin-left"), o = s(n, "margin-right"), l = n.getPropertyValue("box-sizing"); if (l && "border-box" === l) P = e + a + o; else { const { clientWidth: s, offsetWidth: n } = r; P = e + t + i + a + o + (n - s) } } o && (r.style.transform = o), l && (r.style.webkitTransform = l), i.roundLengths && (P = Math.floor(P)) } else P = (n - (i.slidesPerView - 1) * S) / i.slidesPerView, i.roundLengths && (P = Math.floor(P)), p[a] && (p[a].style[t("width")] = `${P}px`); p[a] && (p[a].swiperSlideSize = P), f.push(P), i.centeredSlides ? (E = E + P / 2 + x / 2 + S, 0 === x && 0 !== a && (E = E - n / 2 - S), 0 === a && (E = E - n / 2 - S), Math.abs(E) < .001 && (E = 0), i.roundLengths && (E = Math.floor(E)), L % i.slidesPerGroup == 0 && h.push(E), m.push(E)) : (i.roundLengths && (E = Math.floor(E)), (L - Math.min(e.params.slidesPerGroupSkip, L)) % e.params.slidesPerGroup == 0 && h.push(E), m.push(E), E = E + P + S), e.virtualSize += P + S, x = P, L += 1 } } if (e.virtualSize = Math.max(e.virtualSize, n) + v, o && l && ("slide" === i.effect || "coverflow" === i.effect) && (a.style.width = `${e.virtualSize + S}px`), i.setWrapperSize && (a.style[t("width")] = `${e.virtualSize + S}px`), M && e.grid.updateWrapperSize(P, h, t), !i.centeredSlides) { const t = []; for (let s = 0; s < h.length; s += 1) { let a = h[s]; i.roundLengths && (a = Math.floor(a)), h[s] <= e.virtualSize - n && t.push(a) } h = t, Math.floor(e.virtualSize - n) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - n) } if (d && i.loop) { const t = f[0] + S; if (i.slidesPerGroup > 1) { const s = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup), a = t * i.slidesPerGroup; for (let e = 0; e < s; e += 1)h.push(h[h.length - 1] + a) } for (let s = 0; s < e.virtual.slidesBefore + e.virtual.slidesAfter; s += 1)1 === i.slidesPerGroup && h.push(h[h.length - 1] + t), m.push(m[m.length - 1] + t), e.virtualSize += t } if (0 === h.length && (h = [0]), 0 !== S) { const s = e.isHorizontal() && o ? "marginLeft" : t("marginRight"); p.filter(((e, t) => !(i.cssMode && !i.loop) || t !== p.length - 1)).forEach((e => { e.style[s] = `${S}px` })) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (S || 0) })), e -= S; const t = e - n; h = h.map((e => e <= 0 ? -g : e > t ? t + v : e)) } if (i.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (S || 0) })), e -= S, e < n) { const t = (n - e) / 2; h.forEach(((e, s) => { h[s] = e - t })), m.forEach(((e, s) => { m[s] = e + t })) } } if (Object.assign(e, { slides: p, snapGrid: h, slidesGrid: m, slidesSizesGrid: f }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { y(a, "--swiper-centered-offset-before", -h[0] + "px"), y(a, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], s = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s)) } if (u !== c && e.emit("slidesLengthChange"), h.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), m.length !== b && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), !(d || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) { const t = `${i.containerModifierClass}backface-hidden`, s = e.el.classList.contains(t); u <= i.maxBackfaceHiddenSlides ? s || e.el.classList.add(t) : s && e.el.classList.remove(t) } }, updateAutoHeight: function (e) { const t = this, s = [], i = t.virtual && t.params.virtual.enabled; let a, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const n = e => i ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach((e => { s.push(e) })); else for (a = 0; a < Math.ceil(t.params.slidesPerView); a += 1) { const e = t.activeIndex + a; if (e > t.slides.length && !i) break; s.push(n(e)) } else s.push(n(t.activeIndex)); for (a = 0; a < s.length; a += 1)if (void 0 !== s[a]) { const e = s[a].offsetHeight; r = e > r ? e : r } (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides, s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = (e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop) - s - e.cssOverflowAdjustment() }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const t = this, s = t.params, { slides: i, rtlTranslate: a, snapGrid: r } = t; if (0 === i.length) return; void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset(); let n = -e; a && (n = e), i.forEach((e => { e.classList.remove(s.slideVisibleClass) })), t.visibleSlidesIndexes = [], t.visibleSlides = []; let o = s.spaceBetween; "string" == typeof o && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * t.size : "string" == typeof o && (o = parseFloat(o)); for (let e = 0; e < i.length; e += 1) { const l = i[e]; let d = l.swiperSlideOffset; s.cssMode && s.centeredSlides && (d -= i[0].swiperSlideOffset); const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (l.swiperSlideSize + o), p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (l.swiperSlideSize + o), u = -(n - d), h = u + t.slidesSizesGrid[e]; (u >= 0 && u < t.size - 1 || h > 1 && h <= t.size || u <= 0 && h >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), i[e].classList.add(s.slideVisibleClass)), l.progress = a ? -c : c, l.originalProgress = a ? -p : p } }, updateProgress: function (e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * s || 0 } const s = t.params, i = t.maxTranslate() - t.minTranslate(); let { progress: a, isBeginning: r, isEnd: n, progressLoop: o } = t; const l = r, d = n; if (0 === i) a = 0, r = !0, n = !0; else { a = (e - t.minTranslate()) / i; const s = Math.abs(e - t.minTranslate()) < 1, o = Math.abs(e - t.maxTranslate()) < 1; r = s || a <= 0, n = o || a >= 1, s && (a = 0), o && (a = 1) } if (s.loop) { const s = t.getSlideIndexByData(0), i = t.getSlideIndexByData(t.slides.length - 1), a = t.slidesGrid[s], r = t.slidesGrid[i], n = t.slidesGrid[t.slidesGrid.length - 1], l = Math.abs(e); o = l >= a ? (l - a) / n : (l + n - r) / n, o > 1 && (o -= 1) } Object.assign(t, { progress: a, progressLoop: o, isBeginning: r, isEnd: n }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !d && t.emit("reachEnd toEdge"), (l && !r || d && !n) && t.emit("fromEdge"), t.emit("progress", a) }, updateSlidesClasses: function () { const e = this, { slides: t, params: s, slidesEl: i, activeIndex: a } = e, r = e.virtual && s.virtual.enabled, n = e => T(i, `.${s.slideClass}${e}, swiper-slide${e}`)[0]; let o; if (t.forEach((e => { e.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass) })), r) if (s.loop) { let t = a - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = n(`[data-swiper-slide-index="${t}"]`) } else o = n(`[data-swiper-slide-index="${a}"]`); else o = t[a]; if (o) { o.classList.add(s.slideActiveClass); let e = function (e, t) { const s = []; for (; e.nextElementSibling;) { const i = e.nextElementSibling; t ? i.matches(t) && s.push(i) : s.push(i), e = i } return s }(o, `.${s.slideClass}, swiper-slide`)[0]; s.loop && !e && (e = t[0]), e && e.classList.add(s.slideNextClass); let i = function (e, t) { const s = []; for (; e.previousElementSibling;) { const i = e.previousElementSibling; t ? i.matches(t) && s.push(i) : s.push(i), e = i } return s }(o, `.${s.slideClass}, swiper-slide`)[0]; s.loop && 0 === !i && (i = t[t.length - 1]), i && i.classList.add(s.slidePrevClass) } e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, s = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: i, params: a, activeIndex: r, realIndex: n, snapIndex: o } = t; let l, d = e; const c = e => { let s = e - t.virtual.slidesBefore; return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s }; if (void 0 === d && (d = function (e) { const { slidesGrid: t, params: s } = e, i = e.rtlTranslate ? e.translate : -e.translate; let a; for (let e = 0; e < t.length; e += 1)void 0 !== t[e + 1] ? i >= t[e] && i < t[e + 1] - (t[e + 1] - t[e]) / 2 ? a = e : i >= t[e] && i < t[e + 1] && (a = e + 1) : i >= t[e] && (a = e); return s.normalizeSlideIndex && (a < 0 || void 0 === a) && (a = 0), a }(t)), i.indexOf(s) >= 0) l = i.indexOf(s); else { const e = Math.min(a.slidesPerGroupSkip, d); l = e + Math.floor((d - e) / a.slidesPerGroup) } if (l >= i.length && (l = i.length - 1), d === r) return l !== o && (t.snapIndex = l, t.emit("snapIndexChange")), void (t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = c(d))); let p; p = t.virtual && a.virtual.enabled && a.loop ? c(d) : t.slides[d] ? parseInt(t.slides[d].getAttribute("data-swiper-slide-index") || d, 10) : d, Object.assign(t, { previousSnapIndex: o, snapIndex: l, previousRealIndex: n, realIndex: p, previousIndex: r, activeIndex: d }), t.initialized && q(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (n !== p && t.emit("realIndexChange"), t.emit("slideChange")) }, updateClickedSlide: function (e, t) { const s = this, i = s.params; let a = e.closest(`.${i.slideClass}, swiper-slide`); !a && s.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => { !a && e.matches && e.matches(`.${i.slideClass}, swiper-slide`) && (a = e) })); let r, n = !1; if (a) for (let e = 0; e < s.slides.length; e += 1)if (s.slides[e] === a) { n = !0, r = e; break } if (!a || !n) return s.clickedSlide = void 0, void (s.clickedIndex = void 0); s.clickedSlide = a, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(a.getAttribute("data-swiper-slide-index"), 10) : s.clickedIndex = r, i.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide() } }; var F = { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const { params: t, rtlTranslate: s, translate: i, wrapperEl: a } = this; if (t.virtualTranslate) return s ? -i : i; if (t.cssMode) return i; let r = w(a, e); return r += this.cssOverflowAdjustment(), s && (r = -r), r || 0 }, setTranslate: function (e, t) { const s = this, { rtlTranslate: i, params: a, wrapperEl: r, progress: n } = s; let o, l = 0, d = 0; s.isHorizontal() ? l = i ? -e : e : d = e, a.roundLengths && (l = Math.floor(l), d = Math.floor(d)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? l : d, a.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -l : -d : a.virtualTranslate || (s.isHorizontal() ? l -= s.cssOverflowAdjustment() : d -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${l}px, ${d}px, 0px)`); const c = s.maxTranslate() - s.minTranslate(); o = 0 === c ? 0 : (e - s.minTranslate()) / c, o !== n && s.updateProgress(e), s.emit("setTranslate", s.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, s, i, a) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === i && (i = !0); const r = this, { params: n, wrapperEl: o } = r; if (r.animating && n.preventInteractionOnTransition) return !1; const l = r.minTranslate(), d = r.maxTranslate(); let c; if (c = i && e > l ? l : i && e < d ? d : e, r.updateProgress(c), n.cssMode) { const e = r.isHorizontal(); if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -c; else { if (!r.support.smoothScroll) return E({ swiper: r, targetPosition: -c, side: e ? "left" : "top" }), !0; o.scrollTo({ [e ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, a), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, a), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd")) }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0 } }; function H(e) { let { swiper: t, runCallbacks: s, direction: i, step: a } = e; const { activeIndex: r, previousIndex: n } = t; let o = i; if (o || (o = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${a}`), s && r !== n) { if ("reset" === o) return void t.emit(`slideResetTransition${a}`); t.emit(`slideChangeTransition${a}`), "next" === o ? t.emit(`slideNextTransition${a}`) : t.emit(`slidePrevTransition${a}`) } } var N = { slideTo: function (e, t, s, i, a) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e && (e = parseInt(e, 10)); const r = this; let n = e; n < 0 && (n = 0); const { params: o, snapGrid: l, slidesGrid: d, previousIndex: c, activeIndex: p, rtlTranslate: u, wrapperEl: h, enabled: m } = r; if (r.animating && o.preventInteractionOnTransition || !m && !i && !a) return !1; const f = Math.min(r.params.slidesPerGroupSkip, n); let g = f + Math.floor((n - f) / r.params.slidesPerGroup); g >= l.length && (g = l.length - 1); const v = -l[g]; if (o.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) { const t = -Math.floor(100 * v), s = Math.floor(100 * d[e]), i = Math.floor(100 * d[e + 1]); void 0 !== d[e + 1] ? t >= s && t < i - (i - s) / 2 ? n = e : t >= s && t < i && (n = e + 1) : t >= s && (n = e) } if (r.initialized && n !== p) { if (!r.allowSlideNext && (u ? v > r.translate && v > r.minTranslate() : v < r.translate && v < r.minTranslate())) return !1; if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (p || 0) !== n) return !1 } let w; if (n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(v), w = n > p ? "next" : n < p ? "prev" : "reset", u && -v === r.translate || !u && v === r.translate) return r.updateActiveIndex(n), o.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== o.effect && r.setTranslate(v), "reset" !== w && (r.transitionStart(s, w), r.transitionEnd(s, w)), !1; if (o.cssMode) { const e = r.isHorizontal(), s = u ? v : -v; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), t && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { h[e ? "scrollLeft" : "scrollTop"] = s }))) : h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return E({ swiper: r, targetPosition: s, side: e ? "left" : "top" }), !0; h.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, i), r.transitionStart(s, w), 0 === t ? r.transitionEnd(s, w) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, w)) }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, s, i) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) { e = parseInt(e, 10) } const a = this; let r = e; return a.params.loop && (a.virtual && a.params.virtual.enabled ? r += a.virtual.slidesBefore : r = a.getSlideIndexByData(r)), a.slideTo(r, t, s, i) }, slideNext: function (e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this, { enabled: a, params: r, animating: n } = i; if (!a) return i; let o = r.slidesPerGroup; "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < r.slidesPerGroupSkip ? 1 : o, d = i.virtual && r.virtual.enabled; if (r.loop) { if (n && !d && r.loopPreventsSliding) return !1; if (i.loopFix({ direction: "next" }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && r.cssMode) return requestAnimationFrame((() => { i.slideTo(i.activeIndex + l, e, t, s) })), !0 } return r.rewind && i.isEnd ? i.slideTo(0, e, t, s) : i.slideTo(i.activeIndex + l, e, t, s) }, slidePrev: function (e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this, { params: a, snapGrid: r, slidesGrid: n, rtlTranslate: o, enabled: l, animating: d } = i; if (!l) return i; const c = i.virtual && a.virtual.enabled; if (a.loop) { if (d && !c && a.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } function p(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const u = p(o ? i.translate : -i.translate), h = r.map((e => p(e))); let m = r[h.indexOf(u) - 1]; if (void 0 === m && a.cssMode) { let e; r.forEach(((t, s) => { u >= t && (e = s) })), void 0 !== e && (m = r[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== m && (f = n.indexOf(m), f < 0 && (f = i.activeIndex - 1), "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (f = f - i.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), a.rewind && i.isBeginning) { const a = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(a, e, t, s) } return a.loop && 0 === i.activeIndex && a.cssMode ? (requestAnimationFrame((() => { i.slideTo(f, e, t, s) })), !0) : i.slideTo(f, e, t, s) }, slideReset: function (e, t, s) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s) }, slideToClosest: function (e, t, s, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === i && (i = .5); const a = this; let r = a.activeIndex; const n = Math.min(a.params.slidesPerGroupSkip, r), o = n + Math.floor((r - n) / a.params.slidesPerGroup), l = a.rtlTranslate ? a.translate : -a.translate; if (l >= a.snapGrid[o]) { const e = a.snapGrid[o]; l - e > (a.snapGrid[o + 1] - e) * i && (r += a.params.slidesPerGroup) } else { const e = a.snapGrid[o - 1]; l - e <= (a.snapGrid[o] - e) * i && (r -= a.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, a.slidesGrid.length - 1), a.slideTo(r, e, t, s) }, slideToClickedSlide: function () { const e = this, { params: t, slidesEl: s } = e, i = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let a, r = e.clickedIndex; const n = e.isElement ? "swiper-slide" : `.${t.slideClass}`; if (t.loop) { if (e.animating) return; a = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - i / 2 || r > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), r = e.getSlideIndex(T(s, `${n}[data-swiper-slide-index="${a}"]`)[0]), g((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - i ? (e.loopFix(), r = e.getSlideIndex(T(s, `${n}[data-swiper-slide-index="${a}"]`)[0]), g((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }; var V = { loopCreate: function (e) { const t = this, { params: s, slidesEl: i } = t; if (!s.loop || t.virtual && t.params.virtual.enabled) return; T(i, `.${s.slideClass}, swiper-slide`).forEach(((e, t) => { e.setAttribute("data-swiper-slide-index", t) })), t.loopFix({ slideRealIndex: e, direction: s.centeredSlides ? void 0 : "next" }) }, loopFix: function (e) { let { slideRealIndex: t, slideTo: s = !0, direction: i, setTranslate: a, activeSlideIndex: r, byController: n, byMousewheel: o } = void 0 === e ? {} : e; const l = this; if (!l.params.loop) return; l.emit("beforeLoopFix"); const { slides: d, allowSlidePrev: c, allowSlideNext: p, slidesEl: u, params: h } = l; if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && h.virtual.enabled) return s && (h.centeredSlides || 0 !== l.snapIndex ? h.centeredSlides && l.snapIndex < h.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)), l.allowSlidePrev = c, l.allowSlideNext = p, void l.emit("loopFix"); const m = "auto" === h.slidesPerView ? l.slidesPerViewDynamic() : Math.ceil(parseFloat(h.slidesPerView, 10)); let f = h.loopedSlides || m; f % h.slidesPerGroup != 0 && (f += h.slidesPerGroup - f % h.slidesPerGroup), l.loopedSlides = f; const g = [], v = []; let w = l.activeIndex; void 0 === r ? r = l.getSlideIndex(l.slides.filter((e => e.classList.contains(h.slideActiveClass)))[0]) : w = r; const b = "next" === i || !i, S = "prev" === i || !i; let y = 0, E = 0; if (r < f) { y = Math.max(f - r, h.slidesPerGroup); for (let e = 0; e < f - r; e += 1) { const t = e - Math.floor(e / d.length) * d.length; g.push(d.length - t - 1) } } else if (r > l.slides.length - 2 * f) { E = Math.max(r - (l.slides.length - 2 * f), h.slidesPerGroup); for (let e = 0; e < E; e += 1) { const t = e - Math.floor(e / d.length) * d.length; v.push(t) } } if (S && g.forEach((e => { l.slides[e].swiperLoopMoveDOM = !0, u.prepend(l.slides[e]), l.slides[e].swiperLoopMoveDOM = !1 })), b && v.forEach((e => { l.slides[e].swiperLoopMoveDOM = !0, u.append(l.slides[e]), l.slides[e].swiperLoopMoveDOM = !1 })), l.recalcSlides(), "auto" === h.slidesPerView && l.updateSlides(), h.watchSlidesProgress && l.updateSlidesOffset(), s) if (g.length > 0 && S) if (void 0 === t) { const e = l.slidesGrid[w], t = l.slidesGrid[w + y] - e; o ? l.setTranslate(l.translate - t) : (l.slideTo(w + y, 0, !1, !0), a && (l.touches[l.isHorizontal() ? "startX" : "startY"] += t, l.touchEventsData.currentTranslate = l.translate)) } else a && (l.slideToLoop(t, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate); else if (v.length > 0 && b) if (void 0 === t) { const e = l.slidesGrid[w], t = l.slidesGrid[w - E] - e; o ? l.setTranslate(l.translate - t) : (l.slideTo(w - E, 0, !1, !0), a && (l.touches[l.isHorizontal() ? "startX" : "startY"] += t, l.touchEventsData.currentTranslate = l.translate)) } else l.slideToLoop(t, 0, !1, !0); if (l.allowSlidePrev = c, l.allowSlideNext = p, l.controller && l.controller.control && !n) { const e = { slideRealIndex: t, direction: i, setTranslate: a, activeSlideIndex: r, byController: !0 }; Array.isArray(l.controller.control) ? l.controller.control.forEach((t => { !t.destroyed && t.params.loop && t.loopFix({ ...e, slideTo: t.params.slidesPerView === h.slidesPerView && s }) })) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({ ...e, slideTo: l.controller.control.params.slidesPerView === h.slidesPerView && s }) } l.emit("loopFix") }, loopDestroy: function () { const e = this, { params: t, slidesEl: s } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const i = []; e.slides.forEach((e => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; i[t] = e })), e.slides.forEach((e => { e.removeAttribute("data-swiper-slide-index") })), i.forEach((e => { s.append(e) })), e.recalcSlides(), e.slideTo(e.realIndex, 0) } }; function W(e) { const t = this, s = h(), i = f(), a = t.touchEventsData; a.evCache.push(e); const { params: r, touches: n, enabled: o } = t; if (!o) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; if (t.animating && r.preventInteractionOnTransition) return; !t.animating && r.cssMode && r.loop && t.loopFix(); let l = e; l.originalEvent && (l = l.originalEvent); let d = l.target; if ("wrapper" === r.touchEventsTarget && !t.wrapperEl.contains(d)) return; if ("which" in l && 3 === l.which) return; if ("button" in l && l.button > 0) return; if (a.isTouched && a.isMoved) return; const c = !!r.noSwipingClass && "" !== r.noSwipingClass, p = e.composedPath ? e.composedPath() : e.path; c && l.target && l.target.shadowRoot && p && (d = p[0]); const u = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, m = !(!l.target || !l.target.shadowRoot); if (r.noSwiping && (m ? function (e, t) { return void 0 === t && (t = this), function t(s) { if (!s || s === h() || s === f()) return null; s.assignedSlot && (s = s.assignedSlot); const i = s.closest(e); return i || s.getRootNode ? i || t(s.getRootNode().host) : null }(t) }(u, d) : d.closest(u))) return void (t.allowClick = !0); if (r.swipeHandler && !d.closest(r.swipeHandler)) return; n.currentX = l.pageX, n.currentY = l.pageY; const g = n.currentX, w = n.currentY, b = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection, S = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (b && (g <= S || g >= i.innerWidth - S)) { if ("prevent" !== b) return; e.preventDefault() } Object.assign(a, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), n.startX = g, n.startY = w, a.touchStartTime = v(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, r.threshold > 0 && (a.allowThresholdMove = !1); let y = !0; d.matches(a.focusableElements) && (y = !1, "SELECT" === d.nodeName && (a.isTouched = !1)), s.activeElement && s.activeElement.matches(a.focusableElements) && s.activeElement !== d && s.activeElement.blur(); const E = y && t.allowTouchMove && r.touchStartPreventDefault; !r.touchStartForcePreventDefault && !E || d.isContentEditable || l.preventDefault(), r.freeMode && r.freeMode.enabled && t.freeMode && t.animating && !r.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", l) } function R(e) { const t = h(), s = this, i = s.touchEventsData, { params: a, touches: r, rtlTranslate: n, enabled: o } = s; if (!o) return; if (!a.simulateTouch && "mouse" === e.pointerType) return; let l = e; if (l.originalEvent && (l = l.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", l)); const d = i.evCache.findIndex((e => e.pointerId === l.pointerId)); d >= 0 && (i.evCache[d] = l); const c = i.evCache.length > 1 ? i.evCache[0] : l, p = c.pageX, u = c.pageY; if (l.preventedByNestedSwiper) return r.startX = p, void (r.startY = u); if (!s.allowTouchMove) return l.target.matches(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(r, { startX: p, startY: u, prevX: s.touches.currentX, prevY: s.touches.currentY, currentX: p, currentY: u }), i.touchStartTime = v())); if (a.touchReleaseOnEdges && !a.loop) if (s.isVertical()) { if (u < r.startY && s.translate <= s.maxTranslate() || u > r.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (p < r.startX && s.translate <= s.maxTranslate() || p > r.startX && s.translate >= s.minTranslate()) return; if (t.activeElement && l.target === t.activeElement && l.target.matches(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1); if (i.allowTouchCallbacks && s.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; r.currentX = p, r.currentY = u; const m = r.currentX - r.startX, f = r.currentY - r.startY; if (s.params.threshold && Math.sqrt(m ** 2 + f ** 2) < s.params.threshold) return; if (void 0 === i.isScrolling) { let e; s.isHorizontal() && r.currentY === r.startY || s.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : m * m + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(m)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > a.touchAngle : 90 - e > a.touchAngle) } if (i.isScrolling && s.emit("touchMoveOpposite", l), void 0 === i.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (i.startMoving = !0)), i.isScrolling || s.zoom && s.params.zoom && s.params.zoom.enabled && i.evCache.length > 1) return void (i.isTouched = !1); if (!i.startMoving) return; s.allowClick = !1, !a.cssMode && l.cancelable && l.preventDefault(), a.touchMoveStopPropagation && !a.nested && l.stopPropagation(); let g = s.isHorizontal() ? m : f, w = s.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY; a.oneWayMovement && (g = Math.abs(g) * (n ? 1 : -1), w = Math.abs(w) * (n ? 1 : -1)), r.diff = g, g *= a.touchRatio, n && (g = -g, w = -w); const b = s.touchesDirection; s.swipeDirection = g > 0 ? "prev" : "next", s.touchesDirection = w > 0 ? "prev" : "next"; const S = s.params.loop && !a.cssMode, y = "next" === s.swipeDirection && s.allowSlideNext || "prev" === s.swipeDirection && s.allowSlidePrev; if (!i.isMoved) { if (S && y && s.loopFix({ direction: s.swipeDirection }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) { const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); s.wrapperEl.dispatchEvent(e) } i.allowMomentumBounce = !1, !a.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", l) } let E; i.isMoved && b !== s.touchesDirection && S && y && Math.abs(g) >= 1 && (s.loopFix({ direction: s.swipeDirection, setTranslate: !0 }), E = !0), s.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = g + i.startTranslate; let T = !0, x = a.resistanceRatio; if (a.touchReleaseOnEdges && (x = 0), g > 0 ? (S && y && !E && i.currentTranslate > (a.centeredSlides ? s.minTranslate() - s.size / 2 : s.minTranslate()) && s.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > s.minTranslate() && (T = !1, a.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + g) ** x))) : g < 0 && (S && y && !E && i.currentTranslate < (a.centeredSlides ? s.maxTranslate() + s.size / 2 : s.maxTranslate()) && s.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: s.slides.length - ("auto" === a.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(a.slidesPerView, 10))) }), i.currentTranslate < s.maxTranslate() && (T = !1, a.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - g) ** x))), T && (l.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), a.threshold > 0) { if (!(Math.abs(g) > a.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, void (r.diff = s.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY) } a.followFinger && !a.cssMode && ((a.freeMode && a.freeMode.enabled && s.freeMode || a.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), a.freeMode && a.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate)) } function j(e) { const t = this, s = t.touchEventsData, i = s.evCache.findIndex((t => t.pointerId === e.pointerId)); if (i >= 0 && s.evCache.splice(i, 1), ["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) { if (!(["pointercancel", "contextmenu"].includes(e.type) && (t.browser.isSafari || t.browser.isWebView))) return } const { params: a, touches: r, rtlTranslate: n, slidesGrid: o, enabled: l } = t; if (!l) return; if (!a.simulateTouch && "mouse" === e.pointerType) return; let d = e; if (d.originalEvent && (d = d.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", d), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1); a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = v(), p = c - s.touchStartTime; if (t.allowClick) { const e = d.path || d.composedPath && d.composedPath(); t.updateClickedSlide(e && e[0] || d.target, e), t.emit("tap click", d), p < 300 && c - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", d) } if (s.lastClickTime = v(), g((() => { t.destroyed || (t.allowClick = !0) })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === r.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1); let u; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, u = a.followFinger ? n ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return; if (a.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: u }); let h = 0, m = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; void 0 !== o[e + t] ? u >= o[e] && u < o[e + t] && (h = e, m = o[e + t] - o[e]) : u >= o[e] && (h = e, m = o[o.length - 1] - o[o.length - 2]) } let f = null, w = null; a.rewind && (t.isBeginning ? w = a.virtual && a.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (f = 0)); const b = (u - o[h]) / m, S = h < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (p > a.longSwipesMs) { if (!a.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (b >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? f : h + S) : t.slideTo(h)), "prev" === t.swipeDirection && (b > 1 - a.longSwipesRatio ? t.slideTo(h + S) : null !== w && b < 0 && Math.abs(b) > a.longSwipesRatio ? t.slideTo(w) : t.slideTo(h)) } else { if (!a.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl) ? d.target === t.navigation.nextEl ? t.slideTo(h + S) : t.slideTo(h) : ("next" === t.swipeDirection && t.slideTo(null !== f ? f : h + S), "prev" === t.swipeDirection && t.slideTo(null !== w ? w : h)) } } function Y() { const e = this, { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: a, snapGrid: r } = e, n = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const o = n && t.loop; !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || o ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }), 500)), e.allowSlidePrev = a, e.allowSlideNext = i, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function X(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function U() { const e = this, { wrapperEl: t, rtlTranslate: s, enabled: i } = e; if (!i) return; let a; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); a = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, a !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function K(e) { const t = this; G(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update() } let Z = !1; function Q() { } const J = (e, t) => { const s = h(), { params: i, el: a, wrapperEl: r, device: n } = e, o = !!i.nested, l = "on" === t ? "addEventListener" : "removeEventListener", d = t; a[l]("pointerdown", e.onTouchStart, { passive: !1 }), s[l]("pointermove", e.onTouchMove, { passive: !1, capture: o }), s[l]("pointerup", e.onTouchEnd, { passive: !0 }), s[l]("pointercancel", e.onTouchEnd, { passive: !0 }), s[l]("pointerout", e.onTouchEnd, { passive: !0 }), s[l]("pointerleave", e.onTouchEnd, { passive: !0 }), s[l]("contextmenu", e.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && a[l]("click", e.onClick, !0), i.cssMode && r[l]("scroll", e.onScroll), i.updateOnWindowResize ? e[d](n.ios || n.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Y, !0) : e[d]("observerUpdate", Y, !0), a[l]("load", e.onLoad, { capture: !0 }) }; const ee = (e, t) => e.grid && t.grid && t.grid.rows > 1; var te = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopedSlides: null, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function se(e, t) { return function (s) { void 0 === s && (s = {}); const i = Object.keys(s)[0], a = s[i]; "object" == typeof a && null !== a ? (!0 === e[i] && (e[i] = { enabled: !0 }), "navigation" === i && e[i] && e[i].enabled && !e[i].prevEl && !e[i].nextEl && (e[i].auto = !0), ["pagination", "scrollbar"].indexOf(i) >= 0 && e[i] && e[i].enabled && !e[i].el && (e[i].auto = !0), i in e && "enabled" in a ? ("object" != typeof e[i] || "enabled" in e[i] || (e[i].enabled = !0), e[i] || (e[i] = { enabled: !1 }), S(t, s)) : S(t, s)) : S(t, s) } } const ie = { eventsEmitter: $, update: B, translate: F, transition: { setTransition: function (e, t) { const s = this; s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`, s.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), s.emit("setTransition", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); const s = this, { params: i } = s; i.cssMode || (i.autoHeight && s.updateAutoHeight(), H({ swiper: s, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); const s = this, { params: i } = s; s.animating = !1, i.cssMode || (s.setTransition(0), H({ swiper: s, runCallbacks: e, direction: t, step: "End" })) } }, slide: N, loop: V, grabCursor: { setGrabCursor: function (e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1 })) }, unsetGrabCursor: function () { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1 }))) } }, events: { attachEvents: function () { const e = this, t = h(), { params: s } = e; e.onTouchStart = W.bind(e), e.onTouchMove = R.bind(e), e.onTouchEnd = j.bind(e), s.cssMode && (e.onScroll = U.bind(e)), e.onClick = X.bind(e), e.onLoad = K.bind(e), Z || (t.addEventListener("touchstart", Q), Z = !0), J(e, "on") }, detachEvents: function () { J(this, "off") } }, breakpoints: { setBreakpoint: function () { const e = this, { realIndex: t, initialized: s, params: i, el: a } = e, r = i.breakpoints; if (!r || r && 0 === Object.keys(r).length) return; const n = e.getBreakpoint(r, e.params.breakpointsBase, e.el); if (!n || e.currentBreakpoint === n) return; const o = (n in r ? r[n] : void 0) || e.originalParams, l = ee(e, i), d = ee(e, o), c = i.enabled; l && !d ? (a.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !l && d && (a.classList.add(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && a.classList.add(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { if (void 0 === o[t]) return; const s = i[t] && i[t].enabled, a = o[t] && o[t].enabled; s && !a && e[t].disable(), !s && a && e[t].enable() })); const p = o.direction && o.direction !== i.direction, u = i.loop && (o.slidesPerView !== i.slidesPerView || p), h = i.loop; p && s && e.changeDirection(), S(e.params, o); const m = e.params.enabled, f = e.params.loop; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), c && !m ? e.disable() : !c && m && e.enable(), e.currentBreakpoint = n, e.emit("_beforeBreakpoint", o), s && (u ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !h && f ? (e.loopCreate(t), e.updateSlides()) : h && !f && e.loopDestroy()), e.emit("breakpoint", o) }, getBreakpoint: function (e, t, s) { if (void 0 === t && (t = "window"), !e || "container" === t && !s) return; let i = !1; const a = f(), r = "window" === t ? a.innerHeight : s.clientHeight, n = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: r * t, point: e } } return { value: e, point: e } })); n.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < n.length; e += 1) { const { point: r, value: o } = n[e]; "window" === t ? a.matchMedia(`(min-width: ${o}px)`).matches && (i = r) : o <= s.clientWidth && (i = r) } return i || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: s } = e, { slidesOffsetBefore: i } = s; if (i) { const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i; e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length; !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: s, rtl: i, el: a, device: r } = e, n = function (e, t) { const s = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((i => { e[i] && s.push(t + i) })) : "string" == typeof e && s.push(t + e) })), s }(["initialized", s.direction, { "free-mode": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: i }, { grid: s.grid && s.grid.rows > 1 }, { "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": s.cssMode }, { centered: s.cssMode && s.centeredSlides }, { "watch-progress": s.watchSlidesProgress }], s.containerModifierClass); t.push(...n), a.classList.add(...t), e.emitContainerClasses() }, removeClasses: function () { const { el: e, classNames: t } = this; e.classList.remove(...t), this.emitContainerClasses() } } }, ae = {}; class re { constructor() { let e, t; for (var s = arguments.length, i = new Array(s), a = 0; a < s; a++)i[a] = arguments[a]; 1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = S({}, t), e && !t.el && (t.el = e); const r = h(); if (t.el && "string" == typeof t.el && r.querySelectorAll(t.el).length > 1) { const e = []; return r.querySelectorAll(t.el).forEach((s => { const i = S({}, t, { el: s }); e.push(new re(i)) })), e } const n = this; n.__swiper__ = !0, n.support = _(), n.device = I({ userAgent: t.userAgent }), n.browser = z(), n.eventsListeners = {}, n.eventsAnyListeners = [], n.modules = [...n.__modules__], t.modules && Array.isArray(t.modules) && n.modules.push(...t.modules); const o = {}; n.modules.forEach((e => { e({ params: t, swiper: n, extendParams: se(t, o), on: n.on.bind(n), once: n.once.bind(n), off: n.off.bind(n), emit: n.emit.bind(n) }) })); const l = S({}, te, o); return n.params = S({}, l, ae, t), n.originalParams = S({}, n.params), n.passedParams = S({}, t), n.params && n.params.on && Object.keys(n.params.on).forEach((e => { n.on(e, n.params.on[e]) })), n.params && n.params.onAny && n.onAny(n.params.onAny), Object.assign(n, { enabled: n.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === n.params.direction, isVertical: () => "vertical" === n.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: n.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, evCache: [] }, allowClick: !0, allowTouchMove: n.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), n.emit("_swiper"), n.params.init && n.init(), n } getSlideIndex(e) { const { slidesEl: t, params: s } = this, i = L(T(t, `.${s.slideClass}, swiper-slide`)[0]); return L(e) - i } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0]) } recalcSlides() { const { slidesEl: e, params: t } = this; this.slides = T(e, `.${t.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const s = this; e = Math.min(Math.max(e, 0), 1); const i = s.minTranslate(), a = (s.maxTranslate() - i) * e + i; s.translateTo(a, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach((s => { const i = e.getSlideClasses(s); t.push({ slideEl: s, classNames: i }), e.emit("_slideClass", s, i) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const { params: s, slides: i, slidesGrid: a, slidesSizesGrid: r, size: n, activeIndex: o } = this; let l = 1; if ("number" == typeof s.slidesPerView) return s.slidesPerView; if (s.centeredSlides) { let e, t = i[o] ? i[o].swiperSlideSize : 0; for (let s = o + 1; s < i.length; s += 1)i[s] && !e && (t += i[s].swiperSlideSize, l += 1, t > n && (e = !0)); for (let s = o - 1; s >= 0; s -= 1)i[s] && !e && (t += i[s].swiperSlideSize, l += 1, t > n && (e = !0)) } else if ("current" === e) for (let e = o + 1; e < i.length; e += 1) { (t ? a[e] + r[e] - a[o] < n : a[e] - a[o] < n) && (l += 1) } else for (let e = o - 1; e >= 0; e -= 1) { a[o] - a[e] < n && (l += 1) } return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: s } = e; function i() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses() } let a; if (s.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => { t.complete && G(e, t) })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) i(), s.autoHeight && e.updateAutoHeight(); else { if (("auto" === s.slidesPerView || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) { const t = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides; a = e.slideTo(t.length - 1, 0, !1, !0) } else a = e.slideTo(e.activeIndex, 0, !1, !0); a || i() } s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); const s = this, i = s.params.direction; return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${i}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), s.emit("changeDirection"), t && s.update()), s } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let s = e || t.params.el; if ("string" == typeof s && (s = document.querySelector(s)), !s) return !1; s.swiper = t, s.parentNode && s.parentNode.host && "SWIPER-CONTAINER" === s.parentNode.host.nodeName && (t.isElement = !0); const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let a = (() => { if (s && s.shadowRoot && s.shadowRoot.querySelector) { return s.shadowRoot.querySelector(i()) } return T(s, i())[0] })(); return !a && t.params.createElements && (a = x("div", t.params.wrapperClass), s.append(a), T(s, `.${t.params.slideClass}`).forEach((e => { a.append(e) }))), Object.assign(t, { el: s, wrapperEl: a, slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : a, hostEl: t.isElement ? s.parentNode.host : s, mounted: !0, rtl: "rtl" === s.dir.toLowerCase() || "rtl" === C(s, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === C(s, "direction")), wrongRTL: "-webkit-box" === C(a, "display") }), !0 } init(e) { const t = this; if (t.initialized) return t; if (!1 === t.mount(e)) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const s = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach((e => { e.complete ? G(t, e) : e.addEventListener("load", (e => { G(t, e.target) })) })), q(t), t.initialized = !0, q(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const s = this, { params: i, el: a, wrapperEl: r, slides: n } = s; return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), i.loop && s.loopDestroy(), t && (s.removeClasses(), a.removeAttribute("style"), r.removeAttribute("style"), n && n.length && n.forEach((e => { e.classList.remove(i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") }))), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => { s.off(e) })), !1 !== e && (s.el.swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(s)), s.destroyed = !0), null } static extendDefaults(e) { S(ae, e) } static get extendedDefaults() { return ae } static get defaults() { return te } static installModule(e) { re.prototype.__modules__ || (re.prototype.__modules__ = []); const t = re.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => re.installModule(e))), re) : (re.installModule(e), re) } } function ne(e, t, s, i) { return e.params.createElements && Object.keys(i).forEach((a => { if (!s[a] && !0 === s.auto) { let r = T(e.el, `.${i[a]}`)[0]; r || (r = x("div", i[a]), r.className = i[a], e.el.append(r)), s[a] = r, t[a] = r } })), s } function oe(e) { let { swiper: t, extendParams: s, on: i, emit: a } = e; s({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, prevEl: null }; const r = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)); function n(e) { let s; return e && "string" == typeof e && t.isElement && (s = t.el.querySelector(e), s) ? s : (e && ("string" == typeof e && (s = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.el.querySelectorAll(e).length && (s = t.el.querySelector(e))), e && !s ? e : s) } function o(e, s) { const i = t.params.navigation; (e = r(e)).forEach((e => { e && (e.classList[s ? "add" : "remove"](...i.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = s), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass)) })) } function l() { const { nextEl: e, prevEl: s } = t.navigation; if (t.params.loop) return o(s, !1), void o(e, !1); o(s, t.isBeginning && !t.params.rewind), o(e, t.isEnd && !t.params.rewind) } function d(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), a("navigationPrev")) } function c(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), a("navigationNext")) } function p() { const e = t.params.navigation; if (t.params.navigation = ne(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; let s = n(e.nextEl), i = n(e.prevEl); Object.assign(t.navigation, { nextEl: s, prevEl: i }), s = r(s), i = r(i); const a = (s, i) => { s && s.addEventListener("click", "next" === i ? c : d), !t.enabled && s && s.classList.add(...e.lockClass.split(" ")) }; s.forEach((e => a(e, "next"))), i.forEach((e => a(e, "prev"))) } function u() { let { nextEl: e, prevEl: s } = t.navigation; e = r(e), s = r(s); const i = (e, s) => { e.removeEventListener("click", "next" === s ? c : d), e.classList.remove(...t.params.navigation.disabledClass.split(" ")) }; e.forEach((e => i(e, "next"))), s.forEach((e => i(e, "prev"))) } i("init", (() => { !1 === t.params.navigation.enabled ? h() : (p(), l()) })), i("toEdge fromEdge lock unlock", (() => { l() })), i("destroy", (() => { u() })), i("enable disable", (() => { let { nextEl: e, prevEl: s } = t.navigation; e = r(e), s = r(s), t.enabled ? l() : [...e, ...s].filter((e => !!e)).forEach((e => e.classList.add(t.params.navigation.lockClass))) })), i("click", ((e, s) => { let { nextEl: i, prevEl: n } = t.navigation; i = r(i), n = r(n); const o = s.target; if (t.params.navigation.hideOnClick && !n.includes(o) && !i.includes(o)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === o || t.pagination.el.contains(o))) return; let e; i.length ? e = i[0].classList.contains(t.params.navigation.hiddenClass) : n.length && (e = n[0].classList.contains(t.params.navigation.hiddenClass)), a(!0 === e ? "navigationShow" : "navigationHide"), [...i, ...n].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass))) } })); const h = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), u() }; Object.assign(t.navigation, { enable: () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), p(), l() }, disable: h, update: l, init: p, destroy: u }) } function le(e) { return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function de(e) { let { swiper: t, extendParams: s, on: i, emit: a } = e; const r = "swiper-pagination"; let n; s({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${r}-bullet`, bulletActiveClass: `${r}-bullet-active`, modifierClass: `${r}-`, currentClass: `${r}-current`, totalClass: `${r}-total`, hiddenClass: `${r}-hidden`, progressbarFillClass: `${r}-progressbar-fill`, progressbarOppositeClass: `${r}-progressbar-opposite`, clickableClass: `${r}-clickable`, lockClass: `${r}-lock`, horizontalClass: `${r}-horizontal`, verticalClass: `${r}-vertical`, paginationDisabledClass: `${r}-disabled` } }), t.pagination = { el: null, bullets: [] }; let o = 0; const l = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)); function d() { return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length } function c(e, s) { const { bulletActiveClass: i } = t.params.pagination; e && (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${i}-${s}`), (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${i}-${s}-${s}`)) } function p(e) { const s = e.target.closest(le(t.params.pagination.bulletClass)); if (!s) return; e.preventDefault(); const i = L(s) * t.params.slidesPerGroup; if (t.params.loop) { if (t.realIndex === i) return; const e = t.realIndex, s = t.getSlideIndexByData(i), a = t.getSlideIndexByData(t.realIndex), r = i => { const a = t.activeIndex; t.loopFix({ direction: i, activeSlideIndex: s, slideTo: !1 }); a === t.activeIndex && t.slideToLoop(e, 0, !1, !0) }; if (s > t.slides.length - t.loopedSlides) r(s > a ? "next" : "prev"); else if (t.params.centeredSlides) { const e = "auto" === t.params.slidesPerView ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(t.params.slidesPerView, 10)); s < Math.floor(e / 2) && r("prev") } t.slideToLoop(i) } else t.slideTo(i) } function u() { const e = t.rtl, s = t.params.pagination; if (d()) return; let i, r, p = t.pagination.el; p = l(p); const u = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, h = t.params.loop ? Math.ceil(u / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (r = t.previousRealIndex || 0, i = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (i = t.snapIndex, r = t.previousSnapIndex) : (r = t.previousIndex || 0, i = t.activeIndex || 0), "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) { const a = t.pagination.bullets; let l, d, u; if (s.dynamicBullets && (n = A(a[0], t.isHorizontal() ? "width" : "height", !0), p.forEach((e => { e.style[t.isHorizontal() ? "width" : "height"] = n * (s.dynamicMainBullets + 4) + "px" })), s.dynamicMainBullets > 1 && void 0 !== r && (o += i - (r || 0), o > s.dynamicMainBullets - 1 ? o = s.dynamicMainBullets - 1 : o < 0 && (o = 0)), l = Math.max(i - o, 0), d = l + (Math.min(a.length, s.dynamicMainBullets) - 1), u = (d + l) / 2), a.forEach((e => { const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat(); e.classList.remove(...t) })), p.length > 1) a.forEach((e => { const a = L(e); a === i ? e.classList.add(...s.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), s.dynamicBullets && (a >= l && a <= d && e.classList.add(...`${s.bulletActiveClass}-main`.split(" ")), a === l && c(e, "prev"), a === d && c(e, "next")) })); else { const e = a[i]; if (e && e.classList.add(...s.bulletActiveClass.split(" ")), t.isElement && a.forEach(((e, t) => { e.setAttribute("part", t === i ? "bullet-active" : "bullet") })), s.dynamicBullets) { const e = a[l], t = a[d]; for (let e = l; e <= d; e += 1)a[e] && a[e].classList.add(...`${s.bulletActiveClass}-main`.split(" ")); c(e, "prev"), c(t, "next") } } if (s.dynamicBullets) { const i = Math.min(a.length, s.dynamicMainBullets + 4), r = (n * i - n) / 2 - u * n, o = e ? "right" : "left"; a.forEach((e => { e.style[t.isHorizontal() ? o : "top"] = `${r}px` })) } } p.forEach(((e, r) => { if ("fraction" === s.type && (e.querySelectorAll(le(s.currentClass)).forEach((e => { e.textContent = s.formatFractionCurrent(i + 1) })), e.querySelectorAll(le(s.totalClass)).forEach((e => { e.textContent = s.formatFractionTotal(h) }))), "progressbar" === s.type) { let a; a = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical"; const r = (i + 1) / h; let n = 1, o = 1; "horizontal" === a ? n = r : o = r, e.querySelectorAll(le(s.progressbarFillClass)).forEach((e => { e.style.transform = `translate3d(0,0,0) scaleX(${n}) scaleY(${o})`, e.style.transitionDuration = `${t.params.speed}ms` })) } "custom" === s.type && s.renderCustom ? (e.innerHTML = s.renderCustom(t, i + 1, h), 0 === r && a("paginationRender", e)) : (0 === r && a("paginationRender", e), a("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](s.lockClass) })) } function h() { const e = t.params.pagination; if (d()) return; const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length; let i = t.pagination.el; i = l(i); let r = ""; if ("bullets" === e.type) { let i = t.params.loop ? Math.ceil(s / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && i > s && (i = s); for (let s = 0; s < i; s += 1)e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>` } "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], i.forEach((s => { "custom" !== e.type && (s.innerHTML = r || ""), "bullets" === e.type && t.pagination.bullets.push(...s.querySelectorAll(le(e.bulletClass))) })), "custom" !== e.type && a("paginationRender", i[0]) } function m() { t.params.pagination = ne(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const e = t.params.pagination; if (!e.el) return; let s; "string" == typeof e.el && t.isElement && (s = t.el.querySelector(e.el)), s || "string" != typeof e.el || (s = [...document.querySelectorAll(e.el)]), s || (s = e.el), s && 0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(s) && s.length > 1 && (s = [...t.el.querySelectorAll(e.el)], s.length > 1 && (s = s.filter((e => M(e, ".swiper")[0] === t.el))[0])), Array.isArray(s) && 1 === s.length && (s = s[0]), Object.assign(t.pagination, { el: s }), s = l(s), s.forEach((s => { "bullets" === e.type && e.clickable && s.classList.add(...(e.clickableClass || "").split(" ")), s.classList.add(e.modifierClass + e.type), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`), o = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass), e.clickable && s.addEventListener("click", p), t.enabled || s.classList.add(e.lockClass) }))) } function f() { const e = t.params.pagination; if (d()) return; let s = t.pagination.el; s && (s = l(s), s.forEach((s => { s.classList.remove(e.hiddenClass), s.classList.remove(e.modifierClass + e.type), s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (s.classList.remove(...(e.clickableClass || "").split(" ")), s.removeEventListener("click", p)) }))), t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" ")))) } i("changeDirection", (() => { if (!t.pagination || !t.pagination.el) return; const e = t.params.pagination; let { el: s } = t.pagination; s = l(s), s.forEach((s => { s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) })) })), i("init", (() => { !1 === t.params.pagination.enabled ? g() : (m(), h(), u()) })), i("activeIndexChange", (() => { void 0 === t.snapIndex && u() })), i("snapIndexChange", (() => { u() })), i("snapGridLengthChange", (() => { h(), u() })), i("destroy", (() => { f() })), i("enable disable", (() => { let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))) })), i("lock unlock", (() => { u() })), i("click", ((e, s) => { const i = s.target, r = l(t.pagination.el); if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !i.classList.contains(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && i === t.navigation.nextEl || t.navigation.prevEl && i === t.navigation.prevEl)) return; const e = r[0].classList.contains(t.params.pagination.hiddenClass); a(!0 === e ? "paginationShow" : "paginationHide"), r.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass))) } })); const g = () => { t.el.classList.add(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))), f() }; Object.assign(t.pagination, { enable: () => { t.el.classList.remove(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))), m(), h(), u() }, disable: g, render: h, update: u, init: m, destroy: f }) } Object.keys(ie).forEach((e => { Object.keys(ie[e]).forEach((t => { re.prototype[t] = ie[e][t] })) })), re.use([function (e) { let { swiper: t, on: s, emit: i } = e; const a = f(); let r = null, n = null; const o = () => { t && !t.destroyed && t.initialized && (i("beforeResize"), i("resize")) }, l = () => { t && !t.destroyed && t.initialized && i("orientationchange") }; s("init", (() => { t.params.resizeObserver && void 0 !== a.ResizeObserver ? t && !t.destroyed && t.initialized && (r = new ResizeObserver((e => { n = a.requestAnimationFrame((() => { const { width: s, height: i } = t; let a = s, r = i; e.forEach((e => { let { contentBoxSize: s, contentRect: i, target: n } = e; n && n !== t.el || (a = i ? i.width : (s[0] || s).inlineSize, r = i ? i.height : (s[0] || s).blockSize) })), a === s && r === i || o() })) })), r.observe(t.el)) : (a.addEventListener("resize", o), a.addEventListener("orientationchange", l)) })), s("destroy", (() => { n && a.cancelAnimationFrame(n), r && r.unobserve && t.el && (r.unobserve(t.el), r = null), a.removeEventListener("resize", o), a.removeEventListener("orientationchange", l) })) }, function (e) { let { swiper: t, extendParams: s, on: i, emit: a } = e; const r = [], n = f(), o = function (e, s) { void 0 === s && (s = {}); const i = new (n.MutationObserver || n.WebkitMutationObserver)((e => { if (t.__preventObserver__) return; if (1 === e.length) return void a("observerUpdate", e[0]); const s = function () { a("observerUpdate", e[0]) }; n.requestAnimationFrame ? n.requestAnimationFrame(s) : n.setTimeout(s, 0) })); i.observe(e, { attributes: void 0 === s.attributes || s.attributes, childList: void 0 === s.childList || s.childList, characterData: void 0 === s.characterData || s.characterData }), r.push(i) }; s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", (() => { if (t.params.observer) { if (t.params.observeParents) { const e = M(t.hostEl); for (let t = 0; t < e.length; t += 1)o(e[t]) } o(t.hostEl, { childList: t.params.observeSlideChildren }), o(t.wrapperEl, { attributes: !1 }) } })), i("destroy", (() => { r.forEach((e => { e.disconnect() })), r.splice(0, r.length) })) }]), window.addEventListener("load", (function (e) { document.querySelector(".reviews__slider") && new re(".reviews__slider", { modules: [oe, de], observer: !0, observeParents: !0, slidesPerView: 1, spaceBetween: 300, speed: 800, pagination: { el: ".swiper-pagination", clickable: !0, dynamicBullets: !0 }, on: {} }) })); e.watcher = new class { constructor(e) { this.config = Object.assign({ logging: !0 }, e), this.observer, !document.documentElement.classList.contains("watcher") && this.scrollWatcherRun() } scrollWatcherUpdate() { this.scrollWatcherRun() } scrollWatcherRun() { document.documentElement.classList.add("watcher"), this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]")) } scrollWatcherConstructor(e) { if (e.length) { this.scrollWatcherLogging(`Прокинувся, стежу за об'єктами (${e.length})...`), o(Array.from(e).map((function (e) { return `${e.dataset.watchRoot ? e.dataset.watchRoot : null}|${e.dataset.watchMargin ? e.dataset.watchMargin : "0px"}|${e.dataset.watchThreshold ? e.dataset.watchThreshold : 0}` }))).forEach((t => { let s = t.split("|"), i = { root: s[0], margin: s[1], threshold: s[2] }, a = Array.from(e).filter((function (e) { let t = e.dataset.watchRoot ? e.dataset.watchRoot : null, s = e.dataset.watchMargin ? e.dataset.watchMargin : "0px", a = e.dataset.watchThreshold ? e.dataset.watchThreshold : 0; if (String(t) === i.root && String(s) === i.margin && String(a) === i.threshold) return e })), r = this.getScrollWatcherConfig(i); this.scrollWatcherInit(a, r) })) } else this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz") } getScrollWatcherConfig(e) { let t = {}; if (document.querySelector(e.root) ? t.root = document.querySelector(e.root) : "null" !== e.root && this.scrollWatcherLogging(`Эмм... батьківського об'єкта ${e.root} немає на сторінці`), t.rootMargin = e.margin, !(e.margin.indexOf("px") < 0 && e.margin.indexOf("%") < 0)) { if ("prx" === e.threshold) { e.threshold = []; for (let t = 0; t <= 1; t += .005)e.threshold.push(t) } else e.threshold = e.threshold.split(","); return t.threshold = e.threshold, t } this.scrollWatcherLogging("йой, налаштування data-watch-margin потрібно задавати в PX або %") } scrollWatcherCreate(e) { this.observer = new IntersectionObserver(((e, t) => { e.forEach((e => { this.scrollWatcherCallback(e, t) })) }), e) } scrollWatcherInit(e, t) { this.scrollWatcherCreate(t), e.forEach((e => this.observer.observe(e))) } scrollWatcherIntersecting(e, t) { e.isIntersecting ? (!t.classList.contains("_watcher-view") && t.classList.add("_watcher-view"), this.scrollWatcherLogging(`Я бачу ${t.classList}, додав клас _watcher-view`)) : (t.classList.contains("_watcher-view") && t.classList.remove("_watcher-view"), this.scrollWatcherLogging(`Я не бачу ${t.classList}, прибрав клас _watcher-view`)) } scrollWatcherOff(e, t) { t.unobserve(e), this.scrollWatcherLogging(`Я перестав стежити за ${e.classList}`) } scrollWatcherLogging(e) { this.config.logging && n(`[Спостерігач]: ${e}`) } scrollWatcherCallback(e, t) { const s = e.target; this.scrollWatcherIntersecting(e, s), s.hasAttribute("data-watch-once") && e.isIntersecting && this.scrollWatcherOff(s, t), document.dispatchEvent(new CustomEvent("watcherCallback", { detail: { entry: e } })) } }({}); let ce = !1; setTimeout((() => { if (ce) { let e = new Event("windowScroll"); window.addEventListener("scroll", (function (t) { document.dispatchEvent(e) })) } }), 0), window.FLS = !1, function (e) { let t = new Image; t.onload = t.onerror = function () { e(2 == t.height) }, t.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA" }((function (e) { let t = !0 === e ? "webp" : "no-webp"; document.documentElement.classList.add(t) })), document.querySelector(".icon-menu") && document.addEventListener("click", (function (e) { s && e.target.closest(".icon-menu") && (((e = 500) => { document.documentElement.classList.contains("lock") ? i(e) : a(e) })(), document.documentElement.classList.toggle("menu-open")) })), function (e = { viewPass: !1, autoHeight: !1 }) { if (document.body.addEventListener("focusin", (function (e) { const t = e.target; "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName || (t.hasAttribute("data-no-focus-classes") || (t.classList.add("_form-focus"), t.parentElement.classList.add("_form-focus")), d.removeError(t), t.hasAttribute("data-validate") && d.removeError(t)) })), document.body.addEventListener("focusout", (function (e) { const t = e.target; "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName || (t.hasAttribute("data-no-focus-classes") || (t.classList.remove("_form-focus"), t.parentElement.classList.remove("_form-focus")), t.hasAttribute("data-validate") && d.validateInput(t)) })), e.viewPass && document.addEventListener("click", (function (e) { let t = e.target; if (t.closest('[class*="__viewpass"]')) { let e = t.classList.contains("_viewpass-active") ? "password" : "text"; t.parentElement.querySelector("input").setAttribute("type", e), t.classList.toggle("_viewpass-active") } })), e.autoHeight) { const t = document.querySelectorAll("textarea[data-autoheight]"); if (t.length) { function s(e, t) { e.style.height = `${t}px` } t.forEach((e => { const t = e.hasAttribute("data-autoheight-min") ? Number(e.dataset.autoheightMin) : Number(e.offsetHeight), i = e.hasAttribute("data-autoheight-max") ? Number(e.dataset.autoheightMax) : 1 / 0; s(e, Math.min(t, i)), e.addEventListener("input", (() => { e.scrollHeight > t && (e.style.height = "auto", s(e, Math.min(Math.max(e.scrollHeight, t), i))) })) })) } } }({ viewPass: !1, autoHeight: !1 }), function () { function s(t) { if ("click" === t.type) { const s = t.target; if (s.closest("[data-goto]")) { const i = s.closest("[data-goto]"), a = i.dataset.goto ? i.dataset.goto : "", n = !!i.hasAttribute("data-goto-header"), o = i.dataset.gotoSpeed ? i.dataset.gotoSpeed : 500, d = i.dataset.gotoTop ? parseInt(i.dataset.gotoTop) : 0; if (e.fullpage) { const t = document.querySelector(`${a}`).closest("[data-fp-section]"), s = t ? +t.dataset.fpId : null; null !== s && (e.fullpage.switchingSection(s), document.documentElement.classList.contains("menu-open") && r()) } else l(a, n, o, d); t.preventDefault() } } else if ("watcherCallback" === t.type && t.detail) { const e = t.detail.entry, s = e.target; if ("navigator" === s.dataset.watch) { document.querySelector("[data-goto]._navigator-active"); let t; if (s.id && document.querySelector(`[data-goto="#${s.id}"]`)) t = document.querySelector(`[data-goto="#${s.id}"]`); else if (s.classList.length) for (let e = 0; e < s.classList.length; e++) { const i = s.classList[e]; if (document.querySelector(`[data-goto=".${i}"]`)) { t = document.querySelector(`[data-goto=".${i}"]`); break } } e.isIntersecting ? t && t.classList.add("_navigator-active") : t && t.classList.remove("_navigator-active") } } } if (document.addEventListener("click", s), document.addEventListener("watcherCallback", s), t()) { let e; document.querySelector(`#${t()}`) ? e = `#${t()}` : document.querySelector(`.${t()}`) && (e = `.${t()}`), e && l(e, !0, 500, 20) } }(), function () { ce = !0; const e = document.querySelector("header.header"), t = e.hasAttribute("data-scroll-show"), s = e.dataset.scrollShow ? e.dataset.scrollShow : 500, i = e.dataset.scroll ? e.dataset.scroll : 1; let a, r = 0; document.addEventListener("windowScroll", (function (n) { const o = window.scrollY; clearTimeout(a), o >= i ? (!e.classList.contains("_header-scroll") && e.classList.add("_header-scroll"), t && (o > r ? e.classList.contains("_header-show") && e.classList.remove("_header-show") : !e.classList.contains("_header-show") && e.classList.add("_header-show"), a = setTimeout((() => { !e.classList.contains("_header-show") && e.classList.add("_header-show") }), s))) : (e.classList.contains("_header-scroll") && e.classList.remove("_header-scroll"), t && e.classList.contains("_header-show") && e.classList.remove("_header-show")), r = o <= 0 ? 0 : o })) }(), function () { function e(e) { let t = e || document.querySelectorAll("[data-digits-counter]"); t.length && t.forEach((e => { !function (e) { let t = null; const s = parseFloat(e.dataset.digitsCounterSpeed) ? parseFloat(e.dataset.digitsCounterSpeed) : 1e3, i = parseFloat(e.dataset.digitsCounter), a = e.dataset.digitsCounterFormat ? e.dataset.digitsCounterFormat : " ", r = 0, n = o => { t || (t = o); const l = Math.min((o - t) / s, 1), d = Math.floor(l * (r + i)); e.innerHTML = void 0 !== e.dataset.digitsCounterFormat ? function (e, t = " ") { return e.toString().replace(/(\d)(?=(\d\d\d)+([^\d]|$))/g, `$1${t}`) }(d, a) : d, l < 1 && window.requestAnimationFrame(n) }; window.requestAnimationFrame(n) }(e) })) } document.querySelectorAll("[data-digits-counter]").length && document.querySelectorAll("[data-digits-counter]").forEach((e => { e.dataset.digitsCounter = e.innerHTML, e.innerHTML = "0" })), document.addEventListener("watcherCallback", (function (t) { const s = t.detail.entry.target; s.querySelectorAll("[data-digits-counter]").length && e(s.querySelectorAll("[data-digits-counter]")) })) }() })();